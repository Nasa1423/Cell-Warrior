<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>Cell-Warrior.main API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>Cell-Warrior.main</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
import random
import pygame
from libs import *
import sys
import math
from pygame.mouse import *
from server import *
import os


WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
GRAY = (125, 125, 125)
LIGHT_BLUE = (64, 128, 255)
GREEN = (0, 200, 64)
YELLOW = (225, 225, 0)
PINK = (230, 50, 230)


class Game:

    def __init__(self, width, online=False, server=False, sock=None):
        &#34;&#34;&#34;
        Class Game responsible for drawing the field.

        Args:
            width: the number of cells on the playing field.
        &#34;&#34;&#34;
        self.sock = sock
        self.online = online
        self.server = server
        if online:
            if server == True:
                sock.send(str(width))
            else:
                width = int(sock.recieve())
        pygame.init()
        self.window = pygame.display.set_mode((1280, 720))
        self.window.fill(BLACK)
        pygame.display.set_caption(&#34;Cell-Warrior&#34;)
        pygame.draw.rect(self.window, WHITE, (20, 20, 500, 500))
        self.size = 500 / width
        for horizon in range(1, width):
            first = 20 + horizon * (self.size)
            pygame.draw.line(self.window, BLACK, [first, 20], [first, 520])
        for vertical in range(1, width):
            second = 20 + vertical * (self.size)
            pygame.draw.line(self.window, BLACK, [0, second], [520, second])
        pygame.display.update()
        field_pos = pygame.Rect(20, 20, 500, 500)
        self.fieldImageSave = self.window.subsurface(field_pos)
        pygame.image.save(self.fieldImageSave, &#34;our_field.jpg&#34;)
        self.field_our = FieldImage()
        self.rect_dr = pygame.sprite.Group()
        self.rect_dr.add(self.field_our)
        self.game_manager = GameField(width, width)
        self.bones = Bones()
        self.turn_num = 1
        self.summ1 = 0
        self.summ2 = 0
        self.failed = 0
        while self.failed &lt; 2:
            if online == False:
                self.turn()
                self.turn_num = 2 if self.turn_num == 1 else 1
            else:
                if server and self.turn_num == 1:
                    self.turn()
                else:
                    self.turn_2()
                self.turn_num = 2 if self.turn_num == 1 else 1

        if self.summ1 &gt; self.summ2:
            print(f&#34;First player is winner! {self.summ1} vs {self.summ2}&#34;)
        elif self.summ1 &lt; self.summ2:
            print(f&#34;Second player is winner! {self.summ1} vs {self.summ2}&#34;)
        else:
            print(&#34;DRAW!&#34;)

    def turn(self):
        &#34;&#34;&#34;
        Function is responsible for calculating the moves of the players.

        Returns:
            None
        &#34;&#34;&#34;
        a, b = self.bones.throw()
        x, y = 0, 0
        positions = self.game_manager.getAvalablePositions(Square(x, y, a, b, self.turn_num))
        positions = [x.getCoords() for x in positions[0]]
        coordinates = [[((w - x) / 2 + x + 1) * self.size, ((h - y) / 2 + y + 1) * self.size] for x, y, w, h in positions]
        if coordinates == []:
            self.failed += 1
            return
        self.failed = 0
        sel_positions = -1
        self.rect = Rect_drawing(self.size * a, self.size * b, GREEN) if self.turn_num == 1 else Rect_drawing(self.size * a, self.size * b, PINK)
        self.rect_dr.add(self.rect)
        while True:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
                elif event.type == pygame.MOUSEMOTION:
                    self.window.fill(BLACK)
                    x, y = get_pos()
                    if 520 - 15 &gt; x &gt; 20 + 15 and 20 + 15 &lt; y &lt; 520 - 15:
                        self.window.fill(BLACK)
                        if pygame.mouse.get_focused():
                            coord_x, coord_y = 500, 500
                            minimum_dist = math.hypot(500, 500)
                            for posit in range(len(coordinates)):
                                if math.hypot(x - coordinates[posit][0], y - coordinates[posit][1]) &lt; minimum_dist:
                                    minimum_dist = math.hypot(x - coordinates[posit][0], y - coordinates[posit][1])
                                    coord_x = coordinates[posit][0]
                                    coord_y = coordinates[posit][1]
                                    sel_positions = posit
                            self.rect.control(coord_x, coord_y)
                            self.rect.update()
                elif event.type == pygame.MOUSEBUTTONDOWN:
                    self.window.fill(BLACK)
                    if pygame.mouse.get_focused():
                        self.game_manager.addSquare(positions[sel_positions][0], positions[sel_positions][1], a, b, self.turn_num)
                        if self.turn_num == 1:
                            if self.online and self.server:
                                self.sock.send(&#34;/&#34;.join([str(positions[sel_positions][0]), str(positions[sel_positions][1]), str(a), str(b), str(self.turn_num)]))
                            self.summ1 += a * b
                        elif self.turn_num == 2:
                            self.summ2 += a * b
                        return
                self.rect_dr.update()
                self.rect_dr.draw(self.window)
                pygame.display.flip()

    def turn_2(self):
        posits = self.sock.recieve().split(&#34;/&#34;)
        self.game_manager.addSquare(int(posits[0]), int(posits[1]), int(posits[2]), int(posits[3]), int(posits[4]))
        self.window.fill(BLACK)
        self.rect_dr.update()
        self.rect_dr.draw(self.window)
        pygame.display.flip()



class FieldImage(pygame.sprite.Sprite):
    def __init__(self):
        &#34;&#34;&#34;
        Class FieldImage creates new sprite of field.
        &#34;&#34;&#34;
        pygame.sprite.Sprite.__init__(self)
        self.image = pygame.image.load(&#34;our_field.jpg&#34;).convert_alpha()
        self.rect = self.image.get_rect()
        self.rect.bottomleft = ((20, 520))


class Rect_drawing(pygame.sprite.Sprite):
    def __init__(self, width, height, color):
        &#34;&#34;&#34;
        Class Rect_drawing creates new sprite of rectangle.

        Args:
            width: width of the rectangle.
            height: length of the rectangle.
            color: color of the rectangle.
        &#34;&#34;&#34;
        pygame.sprite.Sprite.__init__(self)
        self.image = pygame.Surface((width, height))
        self.image.fill(color)
        self.rect = self.image.get_rect()
        self.rect.center = (0, 0)
        self.movex = 0
        self.movey = 0
        self.control(600, 400)
        self.update()

    def control(self, x, y):
        &#34;&#34;&#34;
        Def control creates a sprite by coordinates.

        Args:
            x: coordination of X-axis
            y: coordination of Y-axis

        Returns:
            None
        &#34;&#34;&#34;
        self.movex = x
        self.movey = y

    def update(self):
        &#34;&#34;&#34;
        Def update creates a center at the specified coordinates.

        Returns:
            None
        &#34;&#34;&#34;
        self.rect.center = (self.movex, self.movey)

# print(&#34;Вы хотите играть по сети?&#34;)
# answer = input()
# if answer == &#34;Да&#34;:
#     print(&#34;Вы хотите быть клиентом или сервером? 1 - клиент, 2 - сервер.&#34;)
#     player = int(input())
#     if player == 1:
#         sock = Client(&#34;localhost&#34;, 8910)
#         test = Game(25, online=True, sock=sock)
#     elif player == 2:
#         sock = Server()
#         print(&#34;Игрок подключился.&#34;)
#         test = Game(25, online=True, server=True, sock=sock)
# else:
#     test = Game(25)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="Cell-Warrior.main.FieldImage"><code class="flex name class">
<span>class <span class="ident">FieldImage</span></span>
</code></dt>
<dd>
<div class="desc"><p>simple base class for visible game objects</p>
<p>pygame.sprite.Sprite(*groups): return Sprite</p>
<p>The base class for visible game objects. Derived classes will want to
override the Sprite.update() method and assign Sprite.image and Sprite.rect
attributes.
The initializer can accept any number of Group instances that
the Sprite will become a member of.</p>
<p>When subclassing the Sprite class, be sure to call the base initializer
before adding the Sprite to Groups.</p>
<p>Class FieldImage creates new sprite of field.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FieldImage(pygame.sprite.Sprite):
    def __init__(self):
        &#34;&#34;&#34;
        Class FieldImage creates new sprite of field.
        &#34;&#34;&#34;
        pygame.sprite.Sprite.__init__(self)
        self.image = pygame.image.load(&#34;our_field.jpg&#34;).convert_alpha()
        self.rect = self.image.get_rect()
        self.rect.bottomleft = ((20, 520))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pygame.sprite.Sprite</li>
</ul>
</dd>
<dt id="Cell-Warrior.main.Game"><code class="flex name class">
<span>class <span class="ident">Game</span></span>
<span>(</span><span>width, online=False, server=False, sock=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class Game responsible for drawing the field.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>width</code></strong></dt>
<dd>the number of cells on the playing field.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Game:

    def __init__(self, width, online=False, server=False, sock=None):
        &#34;&#34;&#34;
        Class Game responsible for drawing the field.

        Args:
            width: the number of cells on the playing field.
        &#34;&#34;&#34;
        self.sock = sock
        self.online = online
        self.server = server
        if online:
            if server == True:
                sock.send(str(width))
            else:
                width = int(sock.recieve())
        pygame.init()
        self.window = pygame.display.set_mode((1280, 720))
        self.window.fill(BLACK)
        pygame.display.set_caption(&#34;Cell-Warrior&#34;)
        pygame.draw.rect(self.window, WHITE, (20, 20, 500, 500))
        self.size = 500 / width
        for horizon in range(1, width):
            first = 20 + horizon * (self.size)
            pygame.draw.line(self.window, BLACK, [first, 20], [first, 520])
        for vertical in range(1, width):
            second = 20 + vertical * (self.size)
            pygame.draw.line(self.window, BLACK, [0, second], [520, second])
        pygame.display.update()
        field_pos = pygame.Rect(20, 20, 500, 500)
        self.fieldImageSave = self.window.subsurface(field_pos)
        pygame.image.save(self.fieldImageSave, &#34;our_field.jpg&#34;)
        self.field_our = FieldImage()
        self.rect_dr = pygame.sprite.Group()
        self.rect_dr.add(self.field_our)
        self.game_manager = GameField(width, width)
        self.bones = Bones()
        self.turn_num = 1
        self.summ1 = 0
        self.summ2 = 0
        self.failed = 0
        while self.failed &lt; 2:
            if online == False:
                self.turn()
                self.turn_num = 2 if self.turn_num == 1 else 1
            else:
                if server and self.turn_num == 1:
                    self.turn()
                else:
                    self.turn_2()
                self.turn_num = 2 if self.turn_num == 1 else 1

        if self.summ1 &gt; self.summ2:
            print(f&#34;First player is winner! {self.summ1} vs {self.summ2}&#34;)
        elif self.summ1 &lt; self.summ2:
            print(f&#34;Second player is winner! {self.summ1} vs {self.summ2}&#34;)
        else:
            print(&#34;DRAW!&#34;)

    def turn(self):
        &#34;&#34;&#34;
        Function is responsible for calculating the moves of the players.

        Returns:
            None
        &#34;&#34;&#34;
        a, b = self.bones.throw()
        x, y = 0, 0
        positions = self.game_manager.getAvalablePositions(Square(x, y, a, b, self.turn_num))
        positions = [x.getCoords() for x in positions[0]]
        coordinates = [[((w - x) / 2 + x + 1) * self.size, ((h - y) / 2 + y + 1) * self.size] for x, y, w, h in positions]
        if coordinates == []:
            self.failed += 1
            return
        self.failed = 0
        sel_positions = -1
        self.rect = Rect_drawing(self.size * a, self.size * b, GREEN) if self.turn_num == 1 else Rect_drawing(self.size * a, self.size * b, PINK)
        self.rect_dr.add(self.rect)
        while True:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
                elif event.type == pygame.MOUSEMOTION:
                    self.window.fill(BLACK)
                    x, y = get_pos()
                    if 520 - 15 &gt; x &gt; 20 + 15 and 20 + 15 &lt; y &lt; 520 - 15:
                        self.window.fill(BLACK)
                        if pygame.mouse.get_focused():
                            coord_x, coord_y = 500, 500
                            minimum_dist = math.hypot(500, 500)
                            for posit in range(len(coordinates)):
                                if math.hypot(x - coordinates[posit][0], y - coordinates[posit][1]) &lt; minimum_dist:
                                    minimum_dist = math.hypot(x - coordinates[posit][0], y - coordinates[posit][1])
                                    coord_x = coordinates[posit][0]
                                    coord_y = coordinates[posit][1]
                                    sel_positions = posit
                            self.rect.control(coord_x, coord_y)
                            self.rect.update()
                elif event.type == pygame.MOUSEBUTTONDOWN:
                    self.window.fill(BLACK)
                    if pygame.mouse.get_focused():
                        self.game_manager.addSquare(positions[sel_positions][0], positions[sel_positions][1], a, b, self.turn_num)
                        if self.turn_num == 1:
                            if self.online and self.server:
                                self.sock.send(&#34;/&#34;.join([str(positions[sel_positions][0]), str(positions[sel_positions][1]), str(a), str(b), str(self.turn_num)]))
                            self.summ1 += a * b
                        elif self.turn_num == 2:
                            self.summ2 += a * b
                        return
                self.rect_dr.update()
                self.rect_dr.draw(self.window)
                pygame.display.flip()

    def turn_2(self):
        posits = self.sock.recieve().split(&#34;/&#34;)
        self.game_manager.addSquare(int(posits[0]), int(posits[1]), int(posits[2]), int(posits[3]), int(posits[4]))
        self.window.fill(BLACK)
        self.rect_dr.update()
        self.rect_dr.draw(self.window)
        pygame.display.flip()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="Cell-Warrior.main.Game.turn"><code class="name flex">
<span>def <span class="ident">turn</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Function is responsible for calculating the moves of the players.</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def turn(self):
    &#34;&#34;&#34;
    Function is responsible for calculating the moves of the players.

    Returns:
        None
    &#34;&#34;&#34;
    a, b = self.bones.throw()
    x, y = 0, 0
    positions = self.game_manager.getAvalablePositions(Square(x, y, a, b, self.turn_num))
    positions = [x.getCoords() for x in positions[0]]
    coordinates = [[((w - x) / 2 + x + 1) * self.size, ((h - y) / 2 + y + 1) * self.size] for x, y, w, h in positions]
    if coordinates == []:
        self.failed += 1
        return
    self.failed = 0
    sel_positions = -1
    self.rect = Rect_drawing(self.size * a, self.size * b, GREEN) if self.turn_num == 1 else Rect_drawing(self.size * a, self.size * b, PINK)
    self.rect_dr.add(self.rect)
    while True:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.MOUSEMOTION:
                self.window.fill(BLACK)
                x, y = get_pos()
                if 520 - 15 &gt; x &gt; 20 + 15 and 20 + 15 &lt; y &lt; 520 - 15:
                    self.window.fill(BLACK)
                    if pygame.mouse.get_focused():
                        coord_x, coord_y = 500, 500
                        minimum_dist = math.hypot(500, 500)
                        for posit in range(len(coordinates)):
                            if math.hypot(x - coordinates[posit][0], y - coordinates[posit][1]) &lt; minimum_dist:
                                minimum_dist = math.hypot(x - coordinates[posit][0], y - coordinates[posit][1])
                                coord_x = coordinates[posit][0]
                                coord_y = coordinates[posit][1]
                                sel_positions = posit
                        self.rect.control(coord_x, coord_y)
                        self.rect.update()
            elif event.type == pygame.MOUSEBUTTONDOWN:
                self.window.fill(BLACK)
                if pygame.mouse.get_focused():
                    self.game_manager.addSquare(positions[sel_positions][0], positions[sel_positions][1], a, b, self.turn_num)
                    if self.turn_num == 1:
                        if self.online and self.server:
                            self.sock.send(&#34;/&#34;.join([str(positions[sel_positions][0]), str(positions[sel_positions][1]), str(a), str(b), str(self.turn_num)]))
                        self.summ1 += a * b
                    elif self.turn_num == 2:
                        self.summ2 += a * b
                    return
            self.rect_dr.update()
            self.rect_dr.draw(self.window)
            pygame.display.flip()</code></pre>
</details>
</dd>
<dt id="Cell-Warrior.main.Game.turn_2"><code class="name flex">
<span>def <span class="ident">turn_2</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def turn_2(self):
    posits = self.sock.recieve().split(&#34;/&#34;)
    self.game_manager.addSquare(int(posits[0]), int(posits[1]), int(posits[2]), int(posits[3]), int(posits[4]))
    self.window.fill(BLACK)
    self.rect_dr.update()
    self.rect_dr.draw(self.window)
    pygame.display.flip()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Cell-Warrior.main.Rect_drawing"><code class="flex name class">
<span>class <span class="ident">Rect_drawing</span></span>
<span>(</span><span>width, height, color)</span>
</code></dt>
<dd>
<div class="desc"><p>simple base class for visible game objects</p>
<p>pygame.sprite.Sprite(*groups): return Sprite</p>
<p>The base class for visible game objects. Derived classes will want to
override the Sprite.update() method and assign Sprite.image and Sprite.rect
attributes.
The initializer can accept any number of Group instances that
the Sprite will become a member of.</p>
<p>When subclassing the Sprite class, be sure to call the base initializer
before adding the Sprite to Groups.</p>
<p>Class Rect_drawing creates new sprite of rectangle.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>width</code></strong></dt>
<dd>width of the rectangle.</dd>
<dt><strong><code>height</code></strong></dt>
<dd>length of the rectangle.</dd>
<dt><strong><code>color</code></strong></dt>
<dd>color of the rectangle.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Rect_drawing(pygame.sprite.Sprite):
    def __init__(self, width, height, color):
        &#34;&#34;&#34;
        Class Rect_drawing creates new sprite of rectangle.

        Args:
            width: width of the rectangle.
            height: length of the rectangle.
            color: color of the rectangle.
        &#34;&#34;&#34;
        pygame.sprite.Sprite.__init__(self)
        self.image = pygame.Surface((width, height))
        self.image.fill(color)
        self.rect = self.image.get_rect()
        self.rect.center = (0, 0)
        self.movex = 0
        self.movey = 0
        self.control(600, 400)
        self.update()

    def control(self, x, y):
        &#34;&#34;&#34;
        Def control creates a sprite by coordinates.

        Args:
            x: coordination of X-axis
            y: coordination of Y-axis

        Returns:
            None
        &#34;&#34;&#34;
        self.movex = x
        self.movey = y

    def update(self):
        &#34;&#34;&#34;
        Def update creates a center at the specified coordinates.

        Returns:
            None
        &#34;&#34;&#34;
        self.rect.center = (self.movex, self.movey)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pygame.sprite.Sprite</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="Cell-Warrior.main.Rect_drawing.control"><code class="name flex">
<span>def <span class="ident">control</span></span>(<span>self, x, y)</span>
</code></dt>
<dd>
<div class="desc"><p>Def control creates a sprite by coordinates.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong></dt>
<dd>coordination of X-axis</dd>
<dt><strong><code>y</code></strong></dt>
<dd>coordination of Y-axis</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def control(self, x, y):
    &#34;&#34;&#34;
    Def control creates a sprite by coordinates.

    Args:
        x: coordination of X-axis
        y: coordination of Y-axis

    Returns:
        None
    &#34;&#34;&#34;
    self.movex = x
    self.movey = y</code></pre>
</details>
</dd>
<dt id="Cell-Warrior.main.Rect_drawing.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Def update creates a center at the specified coordinates.</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self):
    &#34;&#34;&#34;
    Def update creates a center at the specified coordinates.

    Returns:
        None
    &#34;&#34;&#34;
    self.rect.center = (self.movex, self.movey)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="Cell-Warrior" href="index.html">Cell-Warrior</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="Cell-Warrior.main.FieldImage" href="#Cell-Warrior.main.FieldImage">FieldImage</a></code></h4>
</li>
<li>
<h4><code><a title="Cell-Warrior.main.Game" href="#Cell-Warrior.main.Game">Game</a></code></h4>
<ul class="">
<li><code><a title="Cell-Warrior.main.Game.turn" href="#Cell-Warrior.main.Game.turn">turn</a></code></li>
<li><code><a title="Cell-Warrior.main.Game.turn_2" href="#Cell-Warrior.main.Game.turn_2">turn_2</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Cell-Warrior.main.Rect_drawing" href="#Cell-Warrior.main.Rect_drawing">Rect_drawing</a></code></h4>
<ul class="">
<li><code><a title="Cell-Warrior.main.Rect_drawing.control" href="#Cell-Warrior.main.Rect_drawing.control">control</a></code></li>
<li><code><a title="Cell-Warrior.main.Rect_drawing.update" href="#Cell-Warrior.main.Rect_drawing.update">update</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>